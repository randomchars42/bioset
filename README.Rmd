---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  echo = FALSE,
  comment = "#>",
  fig.path = "README-"
)
```

# bioset

bioset is intended to save you from some dull tasks when dealing with raw data obtained e.g. from a measuring device.

## Installation

You can install bioset from github with:

```{r gh-installation, echo = TRUE, eval = FALSE}
# install.packages("devtools")
devtools::install_github("randomchars42/bioset")
```

## Why? What bioset can do for you

bioset lets you:

* import raw data organised in matrices, e.g. measured values of a 9 x 12 bio-assay plate
* calculate concentrations using samples with known concentrations (calibrators) in your dataset
* calculate means and variability for duplicates / triplicates / ...
* convert your concentrations to (more or less) arbitrary units of concentration

## Example

If you have a data set of raw values (because your measuring device spat it out) and need to somehow organise the data this package might help you.

### Data import

Suppose you have an ods / xls(x) file with raw values obtained from a measurement like this:

```{r}
data <-
  utils::read.csv(
    system.file("extdata", "values.csv", package = "bioset"),
    header = FALSE)
rownames(data) <- LETTERS[1:4]

knitr::kable(
  data,
  row.names = TRUE,
  col.names = as.character(1:6))
```

Save them as `set_1.csv` (like an ods / xls(x) file but much more basic).

Then you can use `set_read()` to get all values with their position as name in a nice tibble:

```{r, echo = TRUE, eval = FALSE}
set_read()
```

```{r}
data <- bioset::set_read(
  file_name = system.file("extdata", "values.csv", package = "bioset")
)
knitr::kable(data)
```

`set_read()` automagically reads `set_1.csv` in your current directory. If you have more than one set use `set_read(num = 2)` to read set 2, etc. If your files are called `plate_1.csv`, `plate_2.csv`, ..., (`run_1.csv`, `run_1.csv`) you can set `file_name = "plate_#NUM#.csv"` (`run_#NUM#.csv`, ...). If your files are stored in `./files/` tell `set_read()` where to look via `path = "./files/"`.

### Naming the values

Before feeding your samples into your measuring device you most likely drafted some sort of plan which position corresponds to which sample (didn't you?).

```{r}
data <-
  utils::read.csv(
    system.file("extdata", "names.csv", package = "bioset"),
    header = FALSE)
rownames(data) <- LETTERS[1:4]

knitr::kable(
  data,
  row.names = TRUE,
  col.names = as.character(1:6))
```

So you had some calibrators (1-4) and samples A, B, C, D, E, F, G, H, each in duplicates.

To easily set the names for your samples just copy the names into your `set_1.csv`:

```{r}
data <-
  utils::read.csv(
    system.file("extdata", "values_names.csv", package = "bioset"),
    header = FALSE)
rownames(data) <- LETTERS[1:8]

knitr::kable(
  data,
  row.names = TRUE,
  col.names = as.character(1:6))
```

Tell `set_read()` your data contains the names and which column should hold those names by setting `additional_vars = c("name")`. This will get you:

```{r, echo = TRUE, eval = FALSE}
set_read(
  additional_vars = c("name")
)
```

```{r}
data <- bioset::set_read(
  file_name = system.file("extdata", "values_names.csv", package = "bioset"),
  additional_vars = c("name")
)
knitr::kable(data)
```

### Encoding additional properties

Suppose samples A, B, C, D were taken at day 1 and E, F, G, H were taken from the same rats / individuals / patients / students on day 2.

It would be more elegant to encode that into the data:

```{r}
data <-
  utils::read.csv(
    system.file("extdata", "values_names_properties.csv", package = "bioset"),
    header = FALSE)
rownames(data) <- LETTERS[1:8]

knitr::kable(
  data,
  row.names = TRUE,
  col.names = as.character(1:6))
```

Now, tell `set_read()` your data contains the names and day by setting `additional_vars = c("name", "day")`. This will get you:

```{r, echo = TRUE, eval = FALSE}
set_read(
  additional_vars = c("name", "day")
)
```

```{r}
data <- bioset::set_read(
  file_name = system.file("extdata", "values_names_properties.csv", package = "bioset"),
  additional_vars = c("name", "day")
)

knitr::kable(data)
```

### Calculating concentrations

Your measuring device only gave you raw values (extinction rates / relative light units / ...). You know the concentrations of CAL1, CAL2, CAL3 and CAL4. Conveniently, the concentrations follow a linear relationship. To get the concentrations for the rest of the samples you need to interpolate between those calibrators.

`set_calc_concentrations()` does exactly this for you:

```{r, echo = TRUE, eval = FALSE}
set_calc_concentrations(
  data,
  cal_names = c("CAL1", "CAL2", "CAL3", "CAL4"),
  cal_values = c(1, 2, 3, 4) # ng / ml
)
```

```{r}
data <- bioset::set_calc_concentrations(
  data,
  cal_names = c("CAL1", "CAL2", "CAL3", "CAL4"),
  cal_values = c(1, 2, 3, 4) # ng / ml
)

knitr::kable(data)
```

Your calibrators are not so linear? Perhaps after a ln-ln transformation? You can use: `model_func = fit_lnln` and `interpolate_func = interpolate_lnln`. Basicallly, you can use any function as `model_function` that returns a model which is understood by your `interpolate-func`.

### Duplicates / Triplicates / ...

So samples were measured in duplicates. For our further research we might want to use the mean and perhaps exclude samples with too much spread in their values.

`set_calc_variability()` to the rescue.

```{r, echo = TRUE, eval = FALSE}
data <- set_calc_variability(
  data = data,
  ids = sample_id,
  value,
  conc
)
```

This will give you the mean and coefficient of variation (as well as n of the samples and the standard deviation) for the columns `value` and `conc`. It will use `sample_id` to determine which rows belong to the same sample.

```{r}
data <- bioset::set_calc_variability(
  data = data,
  ids = sample_id,
  value,
  conc
)

knitr::kable(data)
```
